# GoF design pattern
### 디자인 패턴 이란?
> **디자인 패턴**은 모듈의 세분화된 역할이나 모듈들 간의 인터페이스 구현 방식을 설계할 때 참조할 수 있는 전형적인 해결 방식을 말합니다.
**디자인 패턴**를 통해 설계 문제, 해결 방법, 해결 방법을 언제 적용해야 할지, 그 결과는 무엇인 지 등을 알 수 있습니다.
또한 디자인 패턴은 한 패턴에 변형을 가하거나 어떠한 요구 사항을 반영하면 다른 패턴으로 변형되는 특징이 있습니다.
1995년 GoF(Gang of Four)라고 불리는 *Erich Gamma, Richard Helm, Ralph Johnson, John Vissides*가 처음으로 디자인 패턴을 구체화하였습니다.
GoF의 디자인 패턴은 소프트웨어 공학에서 가장 많이 사용되는 디자인 패턴입니다. 목적에 따라 분류할 시 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개, 총 23개의 패턴으로 구성됩니다.

### GoF design pattern
> GoF design pattern를 분류하는 기준은 총 두 가지가 있습니다.<br><br>
첫째는, **목적**에 따라 분류하는 것입니다.  
목적에 따라 분류 하면 **생성, 구조, 행동** 3가지로 나눌 수 있습니다.  
각각의 패턴이 어떤 일을 하기 위한 것인 지에 관한 것입니다. 생성 패턴은 객체의 생성 과정에 관여, 구조 패턴은 객체의 합성에 관여, 행동 패턴은 객체가 상호작용하는 방법이나 관심사를 분리하는 방법에 관여합니다.<br><br>
둘째는, 범위에 따라 분류하는 것입니다.  
패턴을 주로 **클래스**에 적용하는지, **객체**에 적용하는지 구분하는 것입니다.  
클래스 패턴은 클래스와 서브 클래스 간의 관련성을 다룹니다. 주로 상속을 통해 관련되며, 컴파일 타임에 정적으로 결정됩니다. 객체 패턴은 객체 간의 관련성을 다루고, 런타임에 변경될 수 있는 동적인 성격을 가집니다.

|생성|구조|행동|
|:---:|:---:|:---:|
|추상 팩토리(Abstract Factory)|어댑터(Adapter)|책임 연쇄(Chain of Responsibility)|
|빌더(Builder)|브리지(Bridge)|커맨드(Command)|
|팩토리 메소드(Factory Method)|컴포지트(Composite)|인터프리터(Interpreter)|
|프로토타입(Prototype)|데코레이터(Decorator)|반복자(Iterator)|
|싱글톤(Singleton)|퍼싸드(Facade)|중재자(Mediator)|
||플라이웨이트(Flyweight)|메멘토(Memento)|
||테스트2|옵서버(Observer)|
||프록시(Proxy)|상태(State)|
|||전략(Strategy)|
|||템플릿 메소드(Template Method)|
|||방문자(Visitor)|


###  생성(Creational) 패턴
> 객체 생성(인스턴스화)  
  특정 개체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성 제공
  
|이름|의도|
|---|---|
|추상 팩토리(Abstract Factory)|구체적인 클래스를 지정하지 않고 인터페이스를 통해 서로 연관되는 객체들을 그룹으로 표현함|
|빌더(Builder)|복합 객체의 생성과 표현을 분리하여 동일한 생성 절차에서도 다른 표현 결과를 만들어낼 수 있음|
|팩토리 메소드(Factory Method)|객체 생성을 서브클래스로 위임하여 캡슐화함|
|프로토타입(Prototype)|원본 객체를 복사함으로써 객체를 생성함|
|싱글톤(Singleton)|어떤 클래스의 인스턴스는 하나임을 보장하고 어디서든 참조할 수 있도록 함|


### 구조(Structural) 패턴
> 객체 결합(조합)  
  클래스나 객체를 조합하여 더 큰 구조를 만드는 패턴
  
|이름|의도|
|---|---|
|어댑터(Adapter)|클래스의 인터페이스를 다른 인터페이스로 변환하여 다른 클래스가 이용할 수 있도록 함|
|브리지(Bridge)|구현부에서 추상층을 분리하여 각자 독립적으로 확장할 수 있게 함|
|컴포지트(Composite)|객체들의 관계를 트리 구조로 구성하여 복합 객체와 단일 객체를 구분없이 다룸|
|데코레이터(Decorator)|주어진 상황 및 용도에 따라 어떤 객체에 다른 객체를 덧붙이는 방식|
|퍼싸드(Facade)|서브시스템에 있는 인터페이스 집합에 대해 하나의 통합된 인터페이스(Wrapper) 제공|
|플라이웨이트(Flyweight)|크기가 작은 여러 개의 객체를 매번 생성하지 않고 가능한 한 공유할 수 있도록 하여 메모리를 절약함|
|프록시(Proxy)|접근이 어려운 객체로의 접근을 제어하기 위해 객체의 Surrogate나 Placeholder를 제공|
  
  
### 행위(Behavioral) 패턴
> 객체 간 커뮤니케이션  
객체(클래스)사이에 알고리즘이나 책임 분배에 관련한 패턴  
결합도를 최소화하는 것에 중점을 둔다

|이름|의도|
|---|---|
|책임 연쇄(Chain of Responsibility)|요청을 받는 객체를 연쇄적으로 묶어 요청을 처리하는 객체를 만날 때까지 객체 Chain을 따라 요청을 전달함|
|커맨드(Command)|요청을 객체의 형태로 캡슐화하여 재사용하거나 취소할 수 있도록 저장함|
|인터프리터(Interpreter)|특정 언어의 문법 표현을 정의함|
|반복자(Iterator)|내부를 노출하지 않고 접근이 잦은 어떤 객체의 원소를 순차적으로 접근할 수 있는 동일한 인터페이스 제공|
|중재자(Mediator)|한 집합에 속해있는 객체들의 상호작용을 캡슐화하여 새로운 객체로 정의|
|메멘토(Memento)|객체가 특정 상태로 다시 되돌아올 수 있도록 내부 상태를 실체화|
|옵서버(Observer)|객체 상태가 변할 때 관련 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 함|
|상태(State)|객체의 상태에 따라 동일한 동작을 다르게 처리해야할 때 사용|
|전략(Strategy)|동일 계열의 알고리즘군을 정의하고 캡슐화하여 상호교환이 가능하도록 함|
|템플릿 메소드(Template Method)|상위클래스는 알고리즘의 골격만을 작성하고 구체적인 처리는 서브클래스로 위임함|
|방문자(Visitor)|객체의 원소에 대해 수행할 연산을 분리하여 별도의 클래스로 구성함|
